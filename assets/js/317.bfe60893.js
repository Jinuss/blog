(window.webpackJsonp=window.webpackJsonp||[]).push([[317],{751:function(e,v,_){"use strict";_.r(v);var o=_(4),t=Object(o.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h3",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),v("p",[e._v("我们都知道不管是 "),v("code",[e._v("vue2")]),e._v(" 还是 "),v("code",[e._v("vue3")]),e._v(",都实现了数据和视图的响应式绑定与更新，那么两者有何区别呢？")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("vue2")]),e._v(" 主要是通过数据劫持的方式，通过"),v("code",[e._v("Object.defineProperty")]),e._v("来通过"),v("code",[e._v("set")]),e._v("和"),v("code",[e._v("get")]),e._v("劫持数据，当数据发生变化上，会通知模板引擎重新渲染。本质上 "),v("code",[e._v("vue3")]),e._v(" 的实现思路没有什么不同，不过 "),v("code",[e._v("vue3")]),e._v(" 使用过"),v("code",[e._v("Proxy")]),e._v("进行代理")]),e._v(" "),v("li",[e._v("还有个区别就是"),v("code",[e._v("vue2")]),e._v("会默认让所有的数据具备响应式的能力，而"),v("code",[e._v("vue3")]),e._v("则需要通过"),v("code",[e._v("reactive")]),e._v("和"),v("code",[e._v("ref")]),e._v("来声明响应式数据")])]),e._v(" "),v("h3",{attrs:{id:"proxy-对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#proxy-对象"}},[e._v("#")]),e._v(" "),v("code",[e._v("Proxy")]),e._v(" 对象")]),e._v(" "),v("p",[v("code",[e._v("Proxy")]),e._v("对象用于创建一个对象的代理，从而实现对目标对象的访问拦截和修改（如属性查找、赋值、枚举和函数调用）。")]),e._v(" "),v("ul",[v("li",[e._v("语法："),v("code",[e._v("new Proxy(target, handler)")])])]),e._v(" "),v("p",[v("code",[e._v("target")]),e._v(": 需要代理的目标对象（可以是任何类型，包括原生对象）")]),e._v(" "),v("p",[v("code",[e._v("handler")]),e._v(": 一个对象，其属性是当执行一个操作时定义代理的行为的函数。")]),e._v(" "),v("h4",{attrs:{id:"handler实例方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#handler实例方法"}},[e._v("#")]),e._v(" "),v("code",[e._v("handler")]),e._v("实例方法")]),e._v(" "),v("p",[e._v("参照 MDN 文档，"),v("code",[e._v("handler")]),e._v("可以如下 13 种方法")]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("handler.apply()")]),e._v("：用于拦截函数的调用")]),e._v(" "),v("p",[v("code",[e._v("handler.construct()")]),e._v("：用于拦截构造函数"),v("code",[e._v("new")]),e._v("操作符的调用")]),e._v(" "),v("p",[v("code",[e._v("handler.defineProperty()")]),e._v("：用于拦截对象"),v("code",[e._v("Object.defineProperty()")]),e._v("操作")]),e._v(" "),v("p",[v("code",[e._v("handler.deleteProperty()")]),e._v("：用于拦截对对象属性的"),v("code",[e._v("delete")]),e._v("操作")]),e._v(" "),v("p",[v("code",[e._v("handler.get()")]),e._v("：用于拦截对象属性的读取")]),e._v(" "),v("p",[v("code",[e._v("handler.getOwnPropertyDescriptor()")]),e._v("：用于拦截"),v("code",[e._v("Object.getOwnPropertyDescriptor()")]),e._v("操作")]),e._v(" "),v("p",[v("code",[e._v("handler.getPrototypeOf()")]),e._v("：是一个代理方法，当读取代理对象的原型时，该方法就会被调用")]),e._v(" "),v("p",[v("code",[e._v("handler.has()")]),e._v("：拦截"),v("code",[e._v("in")]),e._v("操作符")]),e._v(" "),v("p",[v("code",[e._v("handler.isExtensible()")]),e._v("：拦截"),v("code",[e._v("Object.isExtensible()")]),e._v("操作")]),e._v(" "),v("p",[v("code",[e._v("handler.ownKeys()")]),e._v("：拦截"),v("code",[e._v("Reflect.ownKeys()")]),e._v("，返回一个数组;还可拦截"),v("code",[e._v("Object.getOwnPropertyNames()")]),e._v("和"),v("code",[e._v("Object.getOwnPropertySymbols()")]),e._v(","),v("code",[e._v("Object.keys()")]),e._v("等")]),e._v(" "),v("p",[v("code",[e._v("handler.preventExtensions()")]),e._v("：拦截"),v("code",[e._v("Object.preventExtensions()")])]),e._v(" "),v("p",[v("code",[e._v("handler.set()")]),e._v(": 拦截"),v("code",[e._v("set")]),e._v("操作")]),e._v(" "),v("p",[v("code",[e._v("handler.setPrototypeOf()")]),e._v("：拦截"),v("code",[e._v("Object.setPrototypeOf()")])])]),e._v(" "),v("h3",{attrs:{id:"proxy在vue3中的应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#proxy在vue3中的应用"}},[e._v("#")]),e._v(" "),v("code",[e._v("Proxy")]),e._v("在"),v("code",[e._v("vue3")]),e._v("中的应用")]),e._v(" "),v("p",[v("code",[e._v("vue3")]),e._v("在"),v("code",[e._v("@vue/reactivity")]),e._v("中首先定义了"),v("code",[e._v("BaseReactiveHandler")]),e._v("类，其中重新定义了"),v("code",[e._v("get")]),e._v("方法，在"),v("code",[e._v("get")]),e._v("方法中会调用"),v("code",[e._v("track")]),e._v("方法，用于收集依赖")]),e._v(" "),v("p",[v("code",[e._v("MutableReactiveHandler")]),e._v("和"),v("code",[e._v("ReadonlyReactiveHandler")]),e._v("会继承"),v("code",[e._v("BaseReactiveHandler")]),e._v("类，前者是用到最多的。")]),e._v(" "),v("p",[v("code",[e._v("MutableReactiveHandler")]),e._v("类除了继承"),v("code",[e._v("BaseReactiveHandler")]),e._v("类外,还重写了"),v("code",[e._v("set")]),e._v("、"),v("code",[e._v("deleteProperty")]),e._v("、"),v("code",[e._v("has")]),e._v("和"),v("code",[e._v("ownKeys")]),e._v("方法，在"),v("code",[e._v("set")]),e._v("和"),v("code",[e._v("deleteProperty")]),e._v("中会调用"),v("code",[e._v("trigger")]),e._v("方法，用于触发依赖。")])])}),[],!1,null,null,null);v.default=t.exports}}]);