---
title: ice.js中Model数据初始化原理
date: 2025-12-10 16:33:08
permalink: /pages/2d1d61/
categories:
  - 前端
  - React
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

# 概述

从宏观方面讲，ice.js的官方数据管理是其插件`@ice/plugin-store`，该插件又是基于`react-redux`、`redux`和`redux-thunk`进行的封装，简化数据（状态）的管理。

`@ice/plugin`的数据是在其`Model`层中定义的，数据是存在于内存中的，因此但浏览器页面进行刷新时，内存中的数据会被删除。而数据的持久化依旧离不开浏览器的`localStorage`。

因此若需要在浏览器刷新前后保持用户的登录状态，可以通过如下伪代码实现：

```js
// app.tsx
const appConfig={
    app:{
        getInitialData(){
            const userInfo=localStorage.getItem('userInfo')
            return {
                initialStates:{
                   userModel:userInfo
                }
            }
        }
    }
}
runApp(appConfig)

// store.ts
const store = createStore({userModel})

// user.ts
const userModel = createModel({
    state:{
      name:'',  
    },
    reducers:{

    }
})
```

`getInitialData`是ice中的内置属性配置，其返回对象中的`initialStates`对象的键值分别对应调用`createStore`时的第一个参数对象中的键和它对应的`state`数据。

本文主要讲述`getInitialData`初始化`Model`层数据的原理。

# 原理解析

## 数据部分

### `createStore`

在使用`@ice/plugin-store`时，肯定会调用`createStore`创建数据仓库`store`。而调用`createStore`会进行其插件的处理。尤其和`provider`插件相关。

### `provider`插件

`provider`插件的核心实现如下:

```js
export default (function (_a) {
    var context = _a.context;
    return {
        onStoreCreated: function (store) {
            var Provider = function (props) {
                var children = props.children, initialStates = props.initialStates;
                if (initialStates) {
                    Object.keys(initialStates).forEach(function (name) {
                        var initialState = initialStates[name];
                        if (initialState && store.dispatch[name][SET_STATE]) {
                            store.dispatch[name][SET_STATE](initialState);
                        }
                    });
                }
                return (
                React.createElement(ReduxProvider, { store: store, context: context }, children));
            };
            return { Provider: Provider, context: context };
        },
    };
});
```

其本质上就是返回一个匿名函数，该函数返回一个包含`onStoreCreated`属性方法的对象。`onStoreCreated`方法接收一个`store`作为参数，返回一个对象，而该对象包括一个`Provider`方法和上下文对象`context`。`Provider`方法中会判断是否存在初始值`initialStates`，若存在，则通过`store.dispatch`更新`name`对应的`Model`层的数据，而后返回一个`Redux Provider` 组件，如此才能在子组件中使用`store`。

`createStore`中会将插件收集起来，然后实例化`icestore`并将插件集合`plugins`传参，并调用其`init`方法。

### `icestore`

`icestore`实例化过程中会调用一个工厂函数`pluginFactory`，`pluginFactory`还会验证插件的三个属性方法（`onStoreCreated`、`onModel`和`middleware`）是否合法。该工厂函数会返回一个`create`方法，用于绑定插件`plugin`的属性和方法的到`pluginFactory`的实例上。

`icestore`实例在调用`init`方法时，会调用`createRedux`返回一个`redux store`，该方法中包含了`redux`中复杂的初始化`store`过程。

后续就是将`redux store`传递给`plugin-provider`的`onStoreCreated`方法，并将其返回值`Provider`和`context`绑定到`icestore`的实例上。

## `Render`部分

在`ice.js`项目中系统的入口就是`runApp(appConfig)`，`runApp`方法是在`@ice/core/runApp.ts`中实现的，其伪代码如下：

```js
function runApp(appConfig){
   setAppConfig(appConfig);
   loadStaticModules(appConfig);
   initHistory && initHistory(appConfig);

   reactAppRenderer({
    appConfig: appConfig,
    buildConfig,
    ErrorBoundary,
    appLifecycle: {
      createBaseApp: frameworkAppBase,
      initAppLifeCycles,
      emitLifeCycles,
    },
  });
}
```
重点关注`reactAppRenderer`方法，该方法是在`react-app-renderer`库中实现的，`reactAppRenderer`方法会判断`appConfig`中是否存在`getInitialData`方法，若存在，则调用，并将其返回值赋值给`context.initialData`,同时将其保存在`__initialData_`变量中，该变量可以通过`getInitialData`方法获取。并且在`reactAppRenderer`方法中还调用了参数`createBaseApp`方法，用于构建应用程序。

```js
const { runtime, appConfig: modifiedAppConfig } = createBaseApp<any>(appConfig, buildConfig, context)`
```

`createBaseApp`模块中实际就是一个函数，如下：

```js
 var loadRuntimeModules = _a.loadRuntimeModules, createElement = _a.createElement, _b = _a.runtimeAPI, runtimeAPI = _b === void 0 ? {} : _b, _c = _a.runtimeValue, runtimeValue = _c === void 0 ? {} : _c;
    var createBaseApp = function (appConfig, buildConfig, context, staticConfig) {
        // Merge default appConfig to user appConfig
        appConfig = mergeDefaultConfig(DEFAULT_APP_CONFIG, appConfig);
        context.createElement = createElement;
        context.enableRouter = runtimeValue.enableRouter;
        // Load runtime modules
        var runtime = new RuntimeModule(appConfig, buildConfig, context, staticConfig);
        Object.keys(runtimeAPI).forEach(function (apiKey) {
            runtime.registerRuntimeAPI(apiKey, runtimeAPI[apiKey]);
        });
        // Assign runtime plugin internal value
        Object.keys(runtimeValue).forEach(function (key) {
            runtime.setRuntimeValue(key, runtimeValue[key]);
        });
        loadRuntimeModules(runtime);
        collectAppLifeCycle(appConfig);
        return {
            runtime: runtime,
            appConfig: appConfig
        };
    };

    return createBaseApp;
```

上述伪代码块中和`store`数据相关的就是`loadRuntimeModules`方法的调用，`loadRuntimeModules`方法顾名思义就是加载运行时需要的模块。在前面提到的`runApp`模块中的`frameworkAppBase`本质上就是`createBaseApp`模块调用的返回值，而其参数`loadRuntimeModules`就是在`ice`核心库中实现的，其源码如下：
```js
function loadRuntimeModules(runtime){
  // module0:react-app插件
  runtime.loadModule(module0);
  // module1:router插件
  runtime.loadModule(module1);
  // module2:store插件
  runtime.loadModule(module2);
  // module3:auth插件
  runtime.loadModule(module3);
}
```

其中参数`runtime`本质上就是在`createBaseApp`中`RuntimeModule`的一个实例，其`loadModule`方法定义如下：
```js
 RuntimeModule.prototype.loadModule = function (module) {
        var enableRouter = this.getRuntimeValue('enableRouter');
        var runtimeAPI = {
            addProvider: this.addProvider,
            addDOMRender: this.addDOMRender,
            applyRuntimeAPI: this.applyRuntimeAPI,
            wrapperPageComponent: this.wrapperPageComponent,
            appConfig: this.appConfig,
            buildConfig: this.buildConfig,
            context: this.context,
            setRenderApp: this.setRenderApp,
            staticConfig: this.staticConfig,
            getRuntimeValue: this.getRuntimeValue,
        };
        if (enableRouter) {
            runtimeAPI = __assign(__assign({}, runtimeAPI), { modifyRoutes: this.modifyRoutes, wrapperRouterRender: this.wrapperRouterRender, modifyRoutesComponent: this.modifyRoutesComponent });
        }
        var runtimeModule = module.default || module;
        if (module)
            runtimeModule(runtimeAPI);
    };
```

在`loadRuntimeModules`方法中加载了`store`的运行时插件,它的实现如下：

```js
// @ts-ignore
import AppStore from '$store';
export default ({ addProvider, appConfig, context: { initialData = {} as any, createElement } }) => {
  const StoreProvider = ({ children }) => {
    const storeConfig = appConfig.store || {};
    let initialStates = {};

    if (initialData.initialStates) {
      initialStates = initialData.initialStates;
    } else if (storeConfig.initialStates) {
      initialStates = storeConfig.initialStates;
    }

    return createElement(AppStore.Provider, {
      initialStates,
      children
    });
  };
  if (AppStore && Object.prototype.hasOwnProperty.call(AppStore, 'Provider')) {
    addProvider(StoreProvider);
  }
};
```



