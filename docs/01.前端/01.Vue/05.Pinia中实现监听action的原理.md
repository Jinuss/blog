---
title: Pinia中实现监听action的原理
date: 2025-11-28 10:05:11
permalink: /pages/6f8dbd/
categories:
  - 前端
  - Vue
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概述

在vue3 + `Pinia`项目中，可以监听`store`中定义的每个`action`执行。

## 正文

### 示例介绍

通过一个示例介绍如何监听`store`中的`action`。

1、定义一个`userStore`,如下：

```js
const useUserStore = defineStore('userStore',{
  state:()=>{
    return {
      name:'',
    } 
  }
  actions:{
    setName(name){
      this.name=name;
      return true;
    } 
  }
})
```

`userStore`中的`state`包含一个`name`属性，以及一个`action``setName`方法用于设置`name`。

2、在组件中监听`setName`：

```js
const userStore = useUserStore();

useStore.$onAction(({name,after,store,onError,args})=>{
  if(name == 'setName'){
    after((arg)=>{
      if(arg){
        console.log('set name success!')      
      }
    })
  } 
})

// 执行action
userStore.setName('Zhang San')
```

在组件中通过`$onAction`方法监听，`$onAction`方法接收一个回调函数`callback`作为参数，`callback`有四个参数，

- `name`：`actions`中的属性名，即方法名称
- `after`：在`action`调用完成后会触发，其`arg`参数为`action`方法的返回值
- `store`：即`userStore`，
- `onError`：在`action`调用时，若出现错误，则会触发
- `args`：表示`action`方法被调用时的参数数组

### 原理解析

### 订阅事件`$onAction`

`store.$onAction(callback)`可以理解成订阅`store`中的所有`action`事件，当`actions`中的事件被触发时，都会执行`callback`回调，而用`name`可以区分是哪一个方法被触发。

在`Pinia`中的源码中，使用`defineStore`定义`store`时，`store`就定义了`$onAction`属性，如下：

```js
const partialStore = {
  $onAction: addSubscription.bind(null,actionSubscriptions)
}

const store = vueDemi.reactive(partialStore);

return store;
```

所以在vue组件中`store.$onAction(callback)`，就相当于执行`addSubscription(actionSubscriptions,callback)`，而`addSubscription`的实现如下：

```js
const noop = () => { };

function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
    subscriptions.push(callback);
    const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
        }
    };
    if (!detached && vueDemi.getCurrentScope()) {
        vueDemi.onScopeDispose(removeSubscription);
    }
    return removeSubscription;
}
```

`addSubscription`方法就是将监听`action`的回调`callback`推入到`actionSubscriptions`数组中，还定义了清除监听的函数`removeSubscription`，并且若参数`detached`不存在或为`false`，则在作用域销毁时清理，最后返回清除函数。

即每个`store`中有一个数组`actionSubscriptions`变量用于存放回调函数`callback`，当`action`被触发时就会触发回调。但是，在`store`的`actions`中定义事件时，就是很简单地写一个对象的属性方法。这是因为`Pinia`给这些属性方法重新包裹了一层。

### `actions`属性方法包装

`Pinia`会给每一个`actions`的属性方法进行一层包装，在`Pinia`中定义了一个`action`函数，其实现如下：

```js
 const action = (fn, name = '') => {
 // fn：actions中的属性值
 // name:actions中的属性名（即后面用于区分的方法名称）   
        if (ACTION_MARKER in fn) {
        // 判断fn方法是否被标记过，若被标记过，则给其赋值，并返回  
            fn[ACTION_NAME] = name;
            return fn;
        }
        // 定义`wrappedAction`方法
        const wrappedAction = function () {
            setActivePinia(pinia);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
                afterCallbackList.push(callback);
            }
            function onError(callback) {
                onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
                args,
                name: wrappedAction[ACTION_NAME],
                store,
                after,
                onError,
            });
            let ret;
            try {
                ret = fn.apply(this && this.$id === $id ? this : store, args);
            }
            catch (error) {
                triggerSubscriptions(onErrorCallbackList, error);
                throw error;
            }
            if (ret instanceof Promise) {
                return ret
                    .then((value) => {
                    triggerSubscriptions(afterCallbackList, value);
                    return value;
                })
                    .catch((error) => {
                    triggerSubscriptions(onErrorCallbackList, error);
                    return Promise.reject(error);
                });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
        };
        // 标记方法，表示方法已经被包装过了
        wrappedAction[ACTION_MARKER] = true;
        // 赋值name，用于在wrappedAction中获取name
        wrappedAction[ACTION_NAME] = name;
        // 最后返回`wrappedAction`
        return wrappedAction;
    }
```

`store`中的`actions`属性对象，会进行`for...in`遍历，调用`action`方法进行包装，在`action`中定义了`wrappedAction`方法，用于封装属性方法，最后将其返回。

因此在如上组件中调用`userStore.setName`实际上执行的不是我们所定义的那个`setName`属性方法，而是经过`action`封装后的方法。

### `actions`属性方法的执行


本质上就是执行`wrappedAction`,其流程如下：

（1）在`wrappedAction`方法中定义了两个数组：

- `afterCallbackList`：`fn`执行完后需要执行的事件队列
- `onErrorCallbackList`：若`fn`的返回值是`Promise`对象且运行报错后，需要执行的错误事件队列

并且在`wrappedAction`中还定义了`after`和`onError`方法，分别用于将对应的事件放到队列中。然后会调用`triggerSubscriptions`方法

```js
function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.slice().forEach((callback) => {
        callback(...args);
    });
}
```
（2）`triggerSubscriptions`方法会去逐个遍历`actionSubscriptions`数组中的`callback`，进行调用，即执行`store.$onAction(callback)`中的`callback`。`callback`中的参数`after`或`onError`实际上就是在`wrappedAction`中定义的两个方法，因此在执行过程中，若`callback`中有`after(cb)`或`onError(cb)`，则会将`cb`回调存放对应的队列数组中，以便在`fn`执行完后使用。
（3）在`try...catch`中通过`apply`执行`fn`方法（即在`store`的`actions`中定义的属性方法）得到其返回值`ret`，
（4）若`catch`捕获到错误，则调用`triggerSubscriptions(onErrorCallbackList, error)`执行`onErrorCallbackList`队列中的事件，并返回错误；
（5）若`ret`是一个`Promise`对象，则执行它，当它被`resolve`时，调用`triggerSubscriptions(afterCallbackList, value)`，即执行`afterCallbackList`队列中的事件；若它被`reject`，则执行`onErrorCallbackList`队列中的事件；
（6）否则调用`triggerSubscriptions`执行`afterCallbackList`队列中的事件
（7）最后返回`ret`

## 总结

`store.$onAction`的监听原理本质上还是**订阅**-**触发**,`$onAction`就是将整个`callback`存放在`store`的`actionSubscriptions`队列中，而`actions`中所有的属性方法在定义`store`时都会被`action`方法重新包装成`wrappedAction`;执行`wrappedAction`时，就会先触发`actionSubscriptions`中的`callback`监听，在这个过程中若存在`after(cb)`或`onError(cb)`，则会将`cb`放到`afterCallbackList`或`onErrorCallbackList`队列中；然后执行`fn`，在合适的时机调用`cb`。