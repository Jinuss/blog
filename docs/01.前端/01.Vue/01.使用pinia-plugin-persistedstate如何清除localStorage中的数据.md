---
title: 使用pinia-plugin-persistedstate如何清除localStorage中的数据
date: 2025-11-25 11:29:14
permalink: /pages/0688ae/
categories:
  - 前端
  - Vue
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概述

vue3前端项目，`pinia`是数据状态管理的官方标配，而`pinia-plugin-persistedstate`则是针对`pinia`库进行数据持久化的插件。

本文主要介绍在使用上述三个库（或插件）时，如何清除持久化后的数据。

## 问题介绍

### 问题来源

某个系统中`userStore`用于存放用户信息，并且使用了`persist`持久化用户信息`userInfo`。编写退出登录逻辑时，在`userStore`的退出`action`中重新赋值`this.userInfo = {}`，并使用`localStorage`直接操作缓存，清除所有缓存数据。打开控制台发现`localStorage`并中依旧残存`userInfo`的缓存数据。

### 问题分析

`this.userInfo`的重新赋值，就是`userStore`的`state`发生了变化，这会触发`pinia-plugin-persistedstate`中的监听，在`pinia-plugin-persistedstate`中有如下代码：

```js
store.$subscribe(
  (_mutation, state) => {
    persistState(state, persistence);
  },
  {
    detached: true
  }
);
```

如上代码会监听`store`中`state`的变化，继而触发`persistState`方法，而`persistState`的实现如下：

```js
function persistState(state, { storage, serializer, key, paths, debug }) {
  try {
    const toStore = Array.isArray(paths) ? pick(state, paths) : state;
    storage.setItem(key, serializer.serialize(toStore));
  } catch (e) {
    if (debug)
      console.error("[pinia-plugin-persistedstate]", e);
  }
}
```
`persistState`会将需要持久化的`state`再次存储到`storage`中。

在`pinia`的源码中，`store`的订阅`subscribe`实现如下：

```js
   $subscribe(callback, options = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => vueDemi.watch(() => pinia.state.value[$id], (state) => {
                if (options.flush === 'sync' ? isSyncListening : isListening) {
                    callback({
                        storeId: $id,
                        type: exports.MutationType.direct,
                        events: debuggerEvents,
                    }, state);
                }
            }, assign({}, $subscribeOptions, options)));
            return removeSubscription;
        }
```

`store.$subscribe`的第一个参数`callback`回调事件是通过`vueDemi.watch`监听某个具体的`store`变化，从而调用的。`vueDemi.watch`实际上就是vue中的`watch`方法。而`watch`方法默认是异步执行的。

即在`userStore`的`action`中执行`this.userInfo = {}`，再清除缓存`localStorage.clear()`，会先改变`userStore`的`state`，此时会触发持久化库`pinia-plugin-persistedstate`中的监听，但是回调函数`callback`不会立即执行，而是会被放在异步队列中，等下一个事件循环中去执行，因此会先执行同步代码清除缓存`localStorage.clear()`，最后才是触发`callback`，在`callback`中拿到最新的`state`数据，调用`persistState`进行数据的再次持久化存储。

### 思考

`pinia`本身就是用于管理数据的，在实际开发中不提倡手动操作（缓存）数据，而且`pinia`提供了`$reset`方法会重置数据。因此可以封装一个统一的`store`管理工具。其实现如下：

```js
// utils/storeManager.ts
import { useUserStore } from '@/stores/user'
import { useAppStore } from '@/stores/app'
import { useSettingsStore } from '@/stores/settings'

export class StoreManager {
  // 清除所有 store 的持久化数据
  static clearAllStores() {
    const stores = [
      useUserStore(),
      useAppStore(),
      useSettingsStore()
      // 添加其他需要清除的 store
    ]
    
    stores.forEach(store => {
      if (store.$reset) {
        store.$reset()
      }
    })
    
    // 可选：手动清除 localStorage 中的残留数据
    this.clearPersistedStorage()
  }
  
  // 清除特定的一组 store
  static clearStores(storeNames: string[]) {
    storeNames.forEach(name => {
      switch (name) {
        case 'user':
          useUserStore().$reset()
          break
        case 'app':
          useAppStore().$reset()
          break
        case 'settings':
          useSettingsStore().$reset()
          break
        // 添加其他 store
      }
    })
  }
  
  // 清除 localStorage 中的持久化数据
  private static clearPersistedStorage() {
    const prefix = 'your-app-name' // 你的应用前缀
    Object.keys(localStorage)
      .filter(key => key.includes('-store')) // 根据你的 key 模式过滤
      .forEach(key => {
        localStorage.removeItem(key)
      })
  }
}
```

## 总结

引发问题的核心就是`vue.watch`的第二个参数回调函数是默认异步执行的，会造成`localStorage.clear`无法清除缓存的错觉。