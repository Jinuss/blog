---
title: watch和watcherEffect源码解析
date: 2025-09-09 11:06:38
permalink: /pages/7ca0e0/
categories:
  - 《vue_core_v3.5.18源码学习》
  - runtime-core运行时核心模块
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

在《响应式中的watch实现》中讲解过`watch`的源码实现，本文主要介绍在`runtime-core`篇中`doWatch`的实现，以及`watch`和`watchEffect`的区别。具体实现是在`packages\runtime-core\src\apiWatch.ts`.


## 源码解析

### `doWatch`

`doWatch`就是基于*reactivity*模块中的`watch`实现的，对参数`options`进行了定制包装，并且支持在服务端渲染中使用。主要是对`scheduler`、`augmentJob`和`call`进行了包装。

`doWatch`的源码实现如下：

```js
function doWatch(source, cb, options = {}) {
    // immediate：是否立即执行回调，deep：是否深度监听 flush:调度时机 once：是否只触发一次
    const { immediate, deep, flush, once } = options;
    // 定义基础配置项
    const baseWatchOptions = shared.extend({}, options);

    // 判断是否立即执行。若存在回调函数cb且immediate为true，或者没有回调函数cb且flush值不为post，则也是会立即执行
    const runsImmediately = cb && immediate || !cb && flush !== 'post';
    
    // SSR 处理
    let ssrCleanup;
    // 若是SSR环境，则isInSSRComponentSetup为true
    if (isInSSRComponentSetup) {
        if (flush === 'sync') {
            // 若flush为sync，则调用useSSRContext获取SSR上下文，并且定义上下文的_watcherHandlers属性
            const ctx = useSSRContext();
            ssrCleanup = ctx._watcherHandles || (ctx._watcherHandles = []);
        } else if (!runsImmediately) {
            // 若flush不是sync且不需要立即运行，则返回一个空操作的停止句柄，即不会允许监听
            const watchStopHandle = () => { };
            watchStopHandle.stop = shared.NOOP;
            watchStopHandle.resume = shared.NOOP;
            watchStopHandle.pause = shared.NOOP;
            return watchStopHandle;
        }
    }
    
    // 获取当前组件实例
    const instance = currentInstance;
    // 定义基础配置项的call方法,保证回调会在`callWithAsyncErrorHandling`中执行，可以捕获异步错误
    baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);

    // 定义isPre变量，若flush不是post也不是sync，则它的值为true，表示是一个前置观察者
    let isPre = false;
    if (flush === 'post') {
        // 若flush是post，则使用queuePostRenderEffect将回调放入后置队列中，在DOM更新后执行
        baseWatchOptions.scheduler = (job) => {
            queuePostRenderEffect(job, instance && instance.suspense);
        }
    } else if (flush !== 'sync') {
        // 若flush不是post也不是sync，这也是使用watchEffect的默认情况，则调用queueJob将job放入队列中，在组件更新前执行，
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
            // 第一次运行job时，isFirstRun为true，会立即运行job；后续job会放入队列中运行，即watchEffect(cb);cb第一次会直接运行，后续cb中的响应式数据发生变化时，cb是在队列中运行的
            if (isFirstRun) {
                job();
            } else {
                queueJob(job);
            }
        }
    }

    // 定义基础配置项的augmentJob方法
    baseWatchOptions.augmentJob = (job) => {
        if (cb) {
            // 若存在回调，则标记job的flags的第2位为1
            job.flags |= 4;
        }
        if (isPre) {
            // 若flush不为post，也不是flush，则表示这是一个前置观察者，标记job的flags的第1位为1
            job.flags |= 2;
            // 若存在实例，则关联组件的实例
            if (instance) {
                job.id = instance.id;
                job.i = instance;
            }
        }
    }

    // 定义watchHandle，实际上就是执行reactivity中的watch方法，返回的就是清理方法
    const watchHandle = reactivity.watch(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
        // 在SSR环境中，若存在清理函数，则将watchHandle放入ssrCleanup中
        if (ssrCleanup) {
            ssrCleanup.push(watchHandle)
        } else if (runsImmediately) {
            // 若是立即执行，则立即调用清理函数
            watchHandle();
        }
    }
    
    // 最后返回清理方法watchHandle
    return watchHandle;
}
```

### 监听方法

基于`doWatch`方法，vue3定义了四种监听方法：`watch`、`watchEffect`、`watchPostEffect`和`watchSyncEffect`。`watchPostEffect`和`watchSyncEffect`就是特殊的`watchEffect`,指定了`flush`的值。

#### `watch`


```js
function watch(source, cb, options) {
    return doWatch(source, cb, options)
}
```

```js
function watchEffect(effect, options) {
    return doWatch(effect, null, options)
}
```

```js
function watchPostEffect(effect, options) {
    return doWatch(effect, null, { flush: "post" })
}
```

```js
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, { flush: "sync" })
}
```