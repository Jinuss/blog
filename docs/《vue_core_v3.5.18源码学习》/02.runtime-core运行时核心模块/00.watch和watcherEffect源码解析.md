---
title: watch和watcherEffect源码解析
date: 2025-09-09 11:06:38
permalink: /pages/7ca0e0/
categories:
  - 《vue_core_v3.5.18源码学习》
  - runtime-core运行时核心模块
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

```js
function doWatch(source, cb, options = {}) {
    const { immediate, deep, flush, once } = options;
    const baseWatchOptions = shared.extend({}, options);
    const runsImmediately = cb && immediate || !cb && flush !== 'post';
    let ssrCleanup;
    if (isInSSRComponentSetup) {
        if (flush === 'sync') {
            const ctx = useSSRContext();
            ssrCleanup = ctx._watcherHandles || (ctx._watcherHandles = []);
        } else if (!runsImmediately) {
            const watchStopHandle = () => { };
            watchStopHandle.stop = shared.NOOP;
            watchStopHandle.resume = shared.NOOP;
            watchStopHandle.pause = shared.NOOP;
            return watchStopHandle;
        }
    }

    const instance = currentInstance;
    baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
    let isPre = false;
    if (flush === 'post') {
        baseWatchOptions.scheduler = (job) => {
            queuePostRenderEffect(job, instance && instance.suspense);
        }
    } else if (flush !== 'sync') {
        isPre = true;
        baseWatchOptions.scheduler = (job, isFirstRun) => {
            if (isFirstRun) {
                job();
            } else {
                queueJob(job);
            }
        }
    }
    baseWatchOptions.augmentJob = (job) => {
        if (cb) {
            job.flags |= 4;
        }
        if (isPre) {
            job.flags |= 2;
            if (instance) {
                job.id = instance.id;
                job.i = instance;
            }
        }
    }

    const watchHandle = reactivity.watch(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
        if (ssrCleanup) {
            ssrCleanup.push(watchHandle)
        } else if (runsImmediately) {
            watchHandle();
        }
    }

    return watchHandle;
}
```

```js
function watch(source, cb, options) {
    return doWatch(source, cb, options)
}
```

```js
function watchEffect(effect, options) {
    return doWatch(effect, null, options)
}
```

```js
function watchPostEffect(effect, options) {
    return doWatch(effect, null, { flush: "post" })
}
```

```js
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, { flush: "sync" })
}
```