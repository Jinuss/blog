---
title: patch中组件的挂载解析
date: 2025-09-23 17:33:39
permalink: /pages/05f7c7/
categories:
  - 《vue_core_v3.5.18源码学习》
  - runtime-core运行时核心模块
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---
## 概览

## 源码解析

### 组件挂载
```js
const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
    if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
    }
    setupComponent(instance, false, optimized);
    if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
            initialVNode.placeholder = placeholder.el;
        }
    } else {
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace, optimized);
    }
}
```



## 辅助方法

### `setupComponent`

```js
function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized || isSSR);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
}
```

### `setupStatefulComponent`

```js
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
        reactivity.pauseTracking();
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        const setupResult = callWithErrorHandling(
            setup,
            instance,
            0,
            [
                instance.props,
                setupContext
            ]
        );
        const isAsyncSetup = shared.isPromise(setupResult);
        reactivity.resetTracking();
        reset();
        if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
            markAsyncBoundary(instance);
        }
        if (isAsyncSetup) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                return setupResult.then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                }).catch((e) => {
                    handleError(e, instance, 0);
                });
            } else {
                instance.asyncDep = setupResult;
            }
        } else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    } else {
        finishComponentSetup(instance, isSSR);
    }
}
```

### `handleSetupResult`

```js
function handleSetupResult(instance, setupResult, isSSR) {
    if (shared.isFunction(setupResult)) {
        if (instance.type.__ssrInlineRender) {
            instance.ssrRender = setupResult;
        } else {
            instance.render = setupResult
        }
    } else if (shared.isObject(setupResult)) {
        instance.setupState = reactivity.proxyRefs(setupResult);
    }
    finishComponentSetup(instance, isSSR);
}
```

### `finishComponentSetup`

```js
function finishComponentSetup(instance, isSSR) {
    const Component = instance.type;
    if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
            const template = Component.template || resolveMergedOptions(instance).template;
            if (template) {
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = shared.extend(shared.extend({ isCustomElement, delimiters }, compilerOptions), componentCompilerOptions)
                Component.render = compile(template, finalCompilerOptions)
            }
        }
        instance.render = Component.render || shared.NOOP;
        if (installWithProxy) {
            installWithProxy(instance);
        }
    }
    const reset = setCurrentInstance(instance);
    reactivity.pauseTracking();
    try {
        applyOptions(instance);
    } finally {
        reactivity.resetTracking();
        reset();
    }
}
```

### `setupRenderEffect`

```js
const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
        if (!instance.isMounted) {
            const { el, props } = initialVNode;
            const { bm, m, parent, root, type } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
                shared.invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
                const hydrateSubTree = () => {
                    instance.subTree = renderComponentRoot(instance);
                    hydrateNode(
                        el,
                        instance.subTree,
                        instance,
                        parentSuspense,
                        null
                    );
                };
                if (isAsyncWrapperVNode && type.__asyncHydrate) {
                    type.__asyncHydrate(
                        el,
                        instance,
                        hydrateSubTree
                    );
                } else {
                    hydrateSubTree();
                }
            } else {
                if (root.ce && // @ts-expect-error _def is private
                    root.ce._def.shadowRoot !== false) {
                    root.ce._injectChildStyle(type);
                }
                const subTree = instance.subTree = renderComponentRoot(instance);
                patch(
                    null,
                    subTree,
                    container,
                    anchor,
                    instance,
                    parentSuspense,
                    namespace
                );
                initialVNode.el = subTree.el;
            }
            if (m) {
                queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                const scopedInitialVNode = initialVNode;
                queuePostRenderEffect(
                    () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                    parentSuspense
                );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
        } else {
            let { next, bu, u, parent, vnode } = instance;
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                    if (!instance.isUnmounted) {
                        componentUpdateFn();
                    }
                });
                return
            }

            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
            } else {
                next = vnode;
            }
            if (bu) {
                shared.invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
                prevTree,
                nextTree,
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el),
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree),
                instance,
                parentSuspense,
                namespace
            );
            next.el = nextTree.el;
            if (originNext === null) {
                updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
                queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                queuePostRenderEffect(
                    () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                    parentSuspense
                );
            }
        }
    };
    instance.scope.on();
    const effect = instance.effect = new reactivity.ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect.run.bind(effect);
    const job = instance.job = effect.runIfDirty.bind(effect);
    job.i = instance;
    job.id = instance.uid;
    effect.scheduler = () => queueJob(job);
    update();
}
```