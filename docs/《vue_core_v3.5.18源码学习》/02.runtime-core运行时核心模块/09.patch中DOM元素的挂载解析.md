---
title: patch中DOM元素的挂载解析
date: 2025-09-25 11:36:58
permalink: /pages/4e082f/
categories:
 - 《vue_core_v3.5.18源码学习》
  - runtime-core运行时核心模块
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

在`patch`方法中，若新虚拟节点`n2`的`shapeFlag`判断是DOM元素，则会调用`processElement`方法处理元素的更新或挂载，若旧虚拟节点`n1`为`null`，则会调用`mountElement`挂载DOM元素。

`mountElement`方法是vue3中挂载元素节点的核心函数，它负责将虚拟节点`VNode`转换为真实的DOM元素并插入到容器中。

## 源码解析

- **参数介绍**

`mountElement`方法的参数说明如下：
- `vnode`：要挂载的虚拟节点
- `container`：挂载的容器元素
- `anchor`：插入的参考位置锚点，新元素会插入到这个锚点之前
- `parentComponent`：父组件实例
- `parentSuspense`：父级`Suspense`实例
- `namespace`：命名空间，如`SVG`
- `slotScopeIds`：插槽作用域ID ，可以用于优化
- `optimized`：是否处于优化模式，用于静态节点优化


- **源码分析**

```js
const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
  let el;
  let vnodeHook;
  const { props, shapeFlag, transition, dirs } = vnode;
  // 创建真实DOM元素
  el = vnode.el = hostCreateElement(
    vnode.type,
    namespace,
    props && props.is,
    props
  );
  // 处理子节点
  if (shapeFlag & 8) {
    // 处理文本节点
    hostSetElementText(el, vnode.children);
  } else if (shapeFlag & 16) {
    // 若节点有子节点，递归挂载子节点
    mountChildren(
      vnode.children,
      el,
      null,
      parentComponent,
      parentSuspense,
      resolveChildrenNamespace(vnode, namespace),
      slotScopeIds,
      optimized
    );
  }
  // 若节点有指令
  if (dirs) {
    // 则调用指令的created钩子
    invokeDirectiveHook(vnode, null, parentComponent, "created");
  }
  // 设置作用域ID，用于Scoped CSS
  setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
  // 处理属性
  if (props) {
    // 遍历props
    for (const key in props) {
      // 将属性设置到元素上，跳过value和保留属性
      if (key !== "value" && !shared.isReservedProp(key)) {
        // 调用hostPatchProp设置属性
        hostPatchProp(el, key, null, props[key], namespace, parentComponent);
      }
    }
    // 单独处理value属性
    if ("value" in props) {
      hostPatchProp(el, "value", null, props.value, namespace);
    }
    // 如果有onVnodeBeforeMount钩子，则调用它
    if (vnodeHook = props.onVnodeBeforeMount) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
  }
  // 调用指令的beforeMount钩子
  if (dirs) {
    invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
  }
  // 处理过渡效果
  const needCallTransitionHooks = needTransition(parentSuspense, transition);
  if (needCallTransitionHooks) {
    transition.beforeEnter(el);
  }
  // 插入元素
  hostInsert(el, container, anchor);
  // 执行挂载后的钩子，推入到队列中
  if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
    queuePostRenderEffect(() => {
      vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
      needCallTransitionHooks && transition.enter(el);
      dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
    }, parentSuspense);
  }
}
```

## 辅助方法

### `mountChildren`


`mountElement`方法挂载DOM元素时，若虚拟节点有子节点，则会调用`mountChildren`挂载子节点。`mountChildren`就是遍历子节点，然后调用`patch`方法，在`patch`方法中根据子节点的`type`或`shapeFlag`进行挂载。

```js
const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
```
在`mountChildren`中调用`patch`方法传入的`child`就是新节点，若`optimized`为`true`，则说明是优化模式，会调用`cloneIfMounted`生成节点；否则调用`normalizeVNode`，该方法会生成虚拟节点。

### `cloneIfMounted`

`cloneIfMounted`方法就是判断虚拟节点是否挂载了，若挂载了，就调用`cloneVNode`方法进行克隆`VNode`；否则直接返回虚拟节点。

```js
function cloneIfMounted(child) {
  // 虚拟节点未挂载时，el元素为null，patchFlag为-1表示没有缓存
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
```

### `cloneVNode`

`cloneVNode`方法用于拷贝复制一份虚拟节点。

```js
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true, // 虚拟节点标志位
    __v_skip: true, // 跳过某些优化
    type: vnode.type, // 节点类型
    props: mergedProps, // 合并后的属性
    key: mergedProps && normalizeKey(mergedProps), // 规范化后的可以
    ref: extraProps && extraProps.ref ? (
      mergeRef && ref ? shared.isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children,// 直接复用子节点
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
```

### `normalizeVNode`

```js
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (shared.isArray(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
```

### `createVNode`

```js
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !shared.isString(klass)) {
      props.class = shared.normalizeClass(klass);
    }
    if (shared.isObject(style)) {
      if (reactivity.isProxy(style) && !shared.isArray(style)) {
        style = shared.extend({}, style);
      }
      props.style = shared.normalizeStyle(style);
    }
  }
  const shapeFlag = shared.isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : shared.isObject(type) ? 4 : shared.isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
```

### `setScopeId`

```js
const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
  if (scopeId) {
    hostSetScopeId(el, scopeId)
  }
  if (slotScopeIds) {
    for (let i = 0; i < slotScopeIds.length; i++) {
      hostSetScopeId(el, slotScopeIds[i])
    }
  }
  if (parentComponent) {
    let subTree = parentComponent.subTree;
    if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
      const parentVNode = parentComponent.vnode;
      setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent)
    }
  }
}
```