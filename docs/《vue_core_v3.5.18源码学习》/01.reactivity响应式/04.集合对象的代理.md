---
title: 集合对象的代理
date: 2025-08-14 17:14:30
permalink: /pages/8964a6/
categories:
  - 《vue_core_v3.5.18源码学习》
  - reactivity响应式
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

vue3中实现集合对象(`Map/WeakMap/Set/WeakSet`)的处理器方法，也是针对四种集合对象的代理方法，如：响应式集合对象、浅层响应式集合对象、只读集合对象和浅层只读集合对象。但是集合对象处理器方法没有使用`class`的集成实现，具体参见`packages\reactivity\src\collectionHandlers.ts`

## 源码分析

首先要理解集合对象的代理方法就是一个包含`get`方法的对象，如下所示：

```js
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
```
### `createInstrumentationGetter`

`createInstrumentationGetter`方法就是用于创建`getter`方法，接受两个参数：`isReadonly`（是否只读）和`shallow`（是否是浅层响应）。

`createInstrumentationGetter`的源码实现如下：

```js
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
```

`createInstrumentationGetter`方法也是一个高阶函数，它返回一个`getter`方法。首先会调用`createInstrumentations`获取一个对象`instrumentations`，该对象内部就是包含vue3针对集合对象`Map`/`WeakMap`/`Set`/`WeakSet`重写的一些实例（静态）方法；然后返回一个`getter`，`getter`内部首先会先判断`key`值是否是`__v_isReactive`、`__v_isReadonly`或者是`__v_raw`，返回值由参数`isReadonly2`或`target`决定；若`key`不是这三者之一，则调用`Reflect.get`，若`key`是`instrumentations`中重写实现的方法名并且也是集合对象的原生方法，则`Reflect.get`的第一个参数是`instrumentations`，否则为`target`。

### `createInstrumentations`

`createInstrumentations`方法的源码实现如下：

```js
function createInstrumentations(readonly, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      !readonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (!!(process.env.NODE_ENV !== "production")) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (!!(process.env.NODE_ENV !== "production")) {
          checkIdentityKeys(target, has, key);
        }
        const oldValue = get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = !!(process.env.NODE_ENV !== "production") ? isMap(target) ? new Map(target) : new Set(target) : void 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly, shallow);
  });
  return instrumentations;
}
```

相比之前的vue3源码，`createInstrumentations`简化了集合对象的重写，参数`readonly`和`shallow`表示是否是只读对象和是否是浅响应式对象，它们决定了返回的对象`instrumentations`中会包含哪些方法以及方法的具体实现。

先来回顾下集合对象分别有哪些方法：

| **方法**           | **`Map`**        | **`Set`**       | **`WeakMap`** | **`WeakSet`** |
| ------------------ | ---------------- | --------------- | ------------- | ------------- |
| `.size`            | ✅                | ✅               | ❌             | ❌             |
| `.set(key, value)` | ✅                | -               | ✅             | -             |
| `.get(key)`        | ✅                | -               | ✅             | -             |
| `.has(key)`        | ✅                | ✅               | ✅             | ✅             |
| `.delete(key)`     | ✅                | ✅               | ✅             | ✅             |
| `.clear()`         | ✅                | ✅               | ❌             | ❌             |
| `.add(value)`      | -                | ✅               | -             | ✅             |
| `.keys()`          | ✅                | ✅               | ❌             | ❌             |
| `.values()`        | ✅                | ✅               | ❌             | ❌             |
| `.entries()`       | ✅                | ✅               | ❌             | ❌             |
| `.forEach()`       | ✅                | ✅               | ❌             | ❌             |
| `Symbol.iterator`  | ✅ (同`.entries`) | ✅ (同`.values`) | ❌             | ❌             |

对比`createInstrumentations`方法，其内部就是定义了如上*12*种方法，如下：

- **`get(key)`**

`get(key)`方法是`Map`和`WeakMap`实例的方法，用于获取指定键对应的值。

`get(key)`接受一个`key`参数，表示键，首先通过`this["__v_raw"]`获取实例`target`，这里的`this`指向的就是`Reflect.get`的第三个参数`receiver`，即`getter`中第三个参数`receiver`表示代理对象。获取代理对象的实例`target`后，调用`toRaw`获取原始数据`rawTarget`以及原始键`rawKey`。然后判断`readonly`，若不是只读对象，则判断`key`是否是原始键`rawKey`，若不是，则为`key`调用`track`建立依赖收集；然后为`rawKey`调用`track`建立依赖。

接着，用`Reflect.getPrototypeOf`获取原始实例`rawTarget`的`has`方法;根据`shallow`和`readonly`来决定`wrap`装饰方法；若是浅层响应，则将`toShallow`赋值给`wrap`；否则判断`readonly`，若是深层响应只读，则`wrap`为`toReadonly`；若是深层响应可写对象，则`wrap`为`toReactive`。这样确保了最后获取的值和原始实例的响应式和只读特性保持一致。

最后通过一些`if...else`获取值，若是`target.has(key)`存在，则返回`wrap(target.get(key))`；否则若是`rawTarget.has(rawKey)`存在，则返回`wrap(target.get(rawKey))`；否则最后判断`target`和`rawTarget`是否是同一对象，若是，则直接返回`target.get(key)`

- **`get size()`

`size`属性是`Map`和`Set`实例的属性，用于获取集合的元素数量。

`get size()`本质上是一个访问器属性方法，内部就是先获取代理对象的实例`target`，然后判断是否只读，若不是只读对象，则调用`track`建立依赖，当该代理对象被迭代时，就会触发响应的依赖（监听）。最后通过`Reflect.get`获取`target`的`size`属性值，并返回。

- **`has(key)`**

`Map`、`Set`、`WeakMap`和`WeakSet`均有`has`方法，用于判断集合是否包含指定的键或值。

`has(key)`方法会先获取代理对象的实例`target`，然后通过`toRaw`获取原始对象`rawTarget`和原始键`rawKey`。判断`readonly`，若不是只读对象，则判断`key`是否是原始键`rawKey`即是否发生了改变，若不等，则为`key`调用`track`建立依赖收集；然后为`rawKey`调用`track`建立依赖。

最后，判断`key`值是否是原始键`rawKey`，若是，则调用`target.has(key)`返回结果；若不是，则优先调用`target.has(key)`，若为`false`,再调用`target.has(rawKey)`返回结果。

- **`forEach(callback, thisArg)`**

`forEach`是`Map`和`Set`的实例方法，用于遍历集合中的元素。接受一个函数`callback`参数和`thisArg`对象。
`forEach`同样会先获取代理对象的实例`target`以及原始对象`rawTarget`，然后根据`shallow`和`readonly`获取装饰函数`wrap`。再根据是否只读，若不是只读对象，则调用`track`建立依赖收集。
最后调用`target.forEach`遍历集合对象，执行`callback`方法，并且调用`wrap`包装键`key`和值`key`。

`add`、`set`、`delete`和`clear`会改变代理对象的实例`target`，因此对于只读对象，不应该调用这些方法，vue3中在开发环境，当对只读集合对象调用者四个方法时，会打印警告信息，内部不会做其他操作。

- **`add(value)`**

`add(value)`是`Set`和`WeakSet`的方法，用于新增元素。

`add(value)`方法接收参数`value`，若是深层响应式对象，并且`value`也是深层响应式且不是只读的，则会调用`toRaw(value)`获取参数的原始值并赋值给`value`。然后获取代理对象的实例`target`以及它的原型`proto`，调用原型的`has`方法判断`target`上是否存在相同的`value`，若不存在即`hadKey`为`false`，则调用`target.add`新增元素，再调用`trigger`触发`target`上与`add`相关的监听；最后返回`this`。这样确保了`Set`上的值都是唯一的，而且最后返回`this`，可以方便进行链式操作。

- **`set(key, value)`**

`set(key,value)`是`Map`和`WeakMap`的实例用于新增键值对的方法。

同`add`方法，`set`方法会对`value`进去去响应式处理，获取原始值`value`。然后获取代理对象的实例`target`，以及从它的原型上获取`has`和`get`方法。然后判断`target`上是否存在`key`属性，若不存在，则将`key`去响应式，继续调用`has`方法判断`target`上是否存在原始`key`属性，记为`hadKey`；调用原型上的`get`方法获取`target`上的`key`值记为旧值`oldValue`；调用`target.set(key,value)`新增键值对。然后判断`hadKey`值的布尔属性，若`hadKey`为`false`，则说明`target`上不存在`key`键和原始`key`键，这是一个新增操作，那么就会调用`trigger`触发`add`相关的监听；若`hadKey`存在，则说明是一个重新赋值的更新操作，判断旧值和新值是否相等，若不等，则调用`trigger`触发`set`相关的监听。最后返回`this`。

- **`delete(key)`**

`Map`、`Set`、`WeakMap`和`WeakSet`均有`delete`方法。对于`Map`和`WeakMap`，该方法是删除指定键值对(即键为`key`)；对于`Set`和`WeakSet`，该方法是删除指定元素(`key`即为元素)。

`delete(key)`方法会先获取代理对象的实例`target`以及其原型上的`has`和`get`方法。然后调用`has`方法来判断`target`上是否存在`key`属性（或键），若不存在，则获取`key`的原始值，判断`target`上是否存在原始`key`，记为`hadKey`；由前面我们知道`get`方法只有`Map`和`WeakMap`的实例才有，因此若是`Set`或`WeakSet`的实例，则不能通过`get`获得旧值`oldValue`；然后调用`target.delete(key)`删除元素结果记为`result`，然后判断`hadKey`的布尔属性，若存在，则调用`trigger`触发`delete`相关的依赖；最后返回`result`.

- **`clear()`**

`clear()`是`Map`和`Set`的实例方法，用于清空集合中的所有元素。

`clear()`方法会先获取代理对象的实例`target`，然后读取对象的`size`判断是否为`0`;然后调用`isMap`判断当前`target`是`Map`实例还是`Set`实例，通过`new`构建新的实例记为`oldTarget`；然后调用`target.clear()`清空元素或者键值对，结果记为`result`。若当前`target`不是空对象，则调用`trigger`触发`clear`相关的监听，旧值是`oldTarget`。

- **`keys()`**、**`values()`**、**`entries()`**、**`Symbol.iterator`**

上述四种方法都是集合对象的迭代器方法，用于遍历集合中的元素，只有`Map`和`Set`实例才有。vue3中是基于`createIterableMethod`重写了它们。

#### `createIterableMethod`

`createIterableMethod`顾名思义，就是用于创建可迭代的方法，接受三个参数：`method`（方法名）、`isReadonly2`（是否只读）、`isShallow2`（是否是浅层响应）。返回一个函数，该函数返回一个对象，实现了`[Symbol.iterator]`方法。其实现如下：

```js
function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
```

`createIterableMethod`返回函数中的`this`依旧是指向代理对象，获取代理对象的对象`target`以及原始对象`rawTarget`，调用`isMap`判断当前原始对象是否是`Map`实例；若`method`方法名是`entries`或者是`Symbol.iterator`且当前原始对象是`Map`的实例,则`isPair`为`true`，否则为`false`。若方法名是`keys`且当前原始对象是`Map`实例，则`isKeyOnly`为`true`

调用`target[method](...args)`获取对象默认的迭代器，记为`innerIterator`。根据是否是浅层响应以及是否只读确定装饰方法`wrap`；若不是只读对象，则调用`track`建立`iterate`相关的依赖收集。

最后的部分就是定义返回的对象,返回对象中包含两个方法:`next()`和`[Symbol.iterator]`。`next`中就是对默认的迭代器进行调用，获取`value`和`done`，若`done`为`true`，说明迭代完了，则直接返回`{value,done}`；若`done`为`false`，则判断是否是`isPair`，若`isPair`为`true`，则说返回`[wrap(value[0]), wrap(value[1])]`；否则直接返回`wrap(value)`。而`[Symbol.iterator]`内部就是返回`this`.

