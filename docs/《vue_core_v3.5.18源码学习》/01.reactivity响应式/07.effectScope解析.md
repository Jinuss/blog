---
title: effectScope解析
date: 2025-08-20 16:04:11
permalink: /pages/8235fe/
categories:
  - 5.18源码学习》
  - reactivity响应式
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概述

`EffectScope`是Vue3中一个响应式系统的辅助类，用于管理响应式效果的作用域。它可以帮助我们更好地组织和管理响应式效果，避免了全局状态的污染和管理的复杂性。

每一个vue组件的实例上都会挂载一个`EffectScope`的实例`scope`，该挂载动作会在`createComponentInstance`中进行。在组件被激活挂载时，会调用`scope.on()`方法，将当前作用域设置为活动作用域；而在组件被卸载或者销毁时，会调用`scope.stop()`方法。

### 源码解析

```js
let activeEffectScope;

class EffectScope{
    constructor(detached=false){
        this.detached = detached;
        this._active = true;
        this._on = 0;
        this.effects = [];
        this.cleanups = [];
        this._isPaused = false;
        this.parent = undefined; 
        this.scopes = undefined;
        this.index = undefined;
        this.prevScope = undefined;
        this.parent = activeEffectScope;
        if(!detached && activeEffectScope){
              this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
        }
    }

    pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
    resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }

  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }

  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }

   stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
```
#### 辅助方法

- **`effectScope`**

```js
function effectScope(detached) {
  return new EffectScope(detached);
}
```

- **`getCurrentScope`**

```js
function getCurrentScope() {
  return activeEffectScope;
}
```
- **`onScopeDispose`**

```js
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
```