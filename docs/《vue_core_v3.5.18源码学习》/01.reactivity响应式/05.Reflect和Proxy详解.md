---
title: Reflect和Proxy详解
date: 2025-08-14 18:20:09
permalink: /pages/dee045/
categories:
  - 《vue_core_v3.5.18源码学习》
  - reactivity响应式
tags:
  -
author:
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

`Proxy`和 `Reflect`是都是在*ES6*中引入的新对象。它们也是 vue3 实现响应式的基础。这篇文章会深入理解分析这两个重要的角色。

## 正文

### `Proxy`

`Proxy`对象用于创建一个对象的代理，从而实现对目标对象的访问拦截和修改（如属性查找、赋值、枚举和函数调用）,修改这些操作的默认行为。

- 语法：`new Proxy(target, handler)`

`target`: 需要代理的目标对象（可以是任何类型，包括原生对象）

`handler`: 一个对象，其属性是当执行一个操作时定义代理的行为的函数。

#### `handler`实例方法

参照 MDN 文档，`handler`可以如下 13 种方法

- **`handler.apply(target,thisArg,args)`

`handler.apply`用于拦截函数的调用、`call`和`apply`操作，返回一个值。如果没有定义该方法，那么调用函数时会直接调用目标函数。

- **`handler.construct(target,args)`**
用于拦截构造函数`new`操作符的调用

- **`handler.defineProperty(target,key,descriptor)`**

`handler.defineProperty`用于拦截对象`Object.defineProperty()`操作，返回一个布尔值。如果返回`false`或者报错，则定义属性操作无效。

- **`handler.deleteProperty(target,key)`**

`handler.deleteProperty`用于拦截对对象属性的`delete`操作，返回一个布尔值。如果返回`false`或者报错，则删除操作无效。

- **`handler.get(target,key,receiver)`**
  
`handler.get`用于拦截对象某个属性的读取操作，返回该属性的值。如果属性不存在，则返回`undefined`。如果属性部署了`getter`，那么`getter`的`this`是指向第三个参数`receiver`，若参数`receiver`省略，则`this`默认指向`target`。

- **`handler.getOwnPropertyDescriptor(target,key)`**

`handler.getOwnPropertyDescriptor`用于拦截`Object.getOwnPropertyDescriptor()`操作，返回属性描述对象`Descriptor`或者`undefined`。

- **`handler.getPrototypeOf(target)`**

`handler.getPrototypeOf(target)`用于拦截获取对象原型，会拦截如下操作：`Object.prototype.__prototype_`、`Object.prototype.isPrototypeOf()`、`Object.getPrototype()`、`Reflect.getPrototypeOf()`和`instanceof`等操作。

`handler.getPrototypeOf`的返回值必须是对象或者`null`，否则会报错。若`target`是不可扩展的，则必须返回目标对象的原型对象。

- **`handler.has()`**
拦截`in`操作符

- **`handler.isExtensible(target)`**

`handler.isExtensible(target)`用于拦截`Object.isExtensible()`操作，返回一个布尔值，并且该布尔值与`target`的`isExtensible`属性值相同，否则会报错。

- **`handler.ownKeys(target)`**
`handler.ownKeys`方法用于拦截对对象自身属性的读取操作返回一个数组;如`Object.getOwnPropertyNames()`和`Object.getOwnPropertySymbols()`,`Object.keys()`和`for...in`等

- **`handler.preventExtensions(target)`**

`handler.preventExtensions`方法用于拦截`Object.preventExtensions()`，该方法必须返回一个布尔值，否则会被自动转为布尔值。

- **`handler.set(target,key,value,receiver)`**
  
`handler.set`用于拦截对象某个属性的赋值操作，返回一个布尔值。如果赋值成功，则返回`true`；否则，返回`false`。如果属性部署了`setter`，那么`setter`的`this`是指向第四个参数`receiver`，若参数`receiver`省略，则`this`默认指向`target`。

- **`handler.setPrototypeOf(target,prototype)`**

`handler.setPrototypeOf`方法主要用于拦截`Object.setPrototypeOf()`方法，返回一个布尔值。如果设置成功，则返回`true`；否则，返回`false`。

### `Reflect`

`Reflect`对象是*ES6*为了操作对象而提供的新 API，它提供了拦截 JavaScript 操作对象的方法。这些方法与`Proxy`的`handler`方法相对应。

#### `Reflect`静态方法

`Reflect`对象一共有 13 个静态方法，大部分与`Object`对象的同名方法的作用相同，并且与`Proxy`对象的方法相对应。

- **`Reflect.apply(func,thisArg,args)`**

`Reflect.apply`方法用于调用函数，返回函数执行结果。该方法与`Function.prototype.apply()`方法功能相同，但是`Reflect.apply`方法的参数是`func`函数、`this`对象和参数数组，返回值是函数执行结果。

- **`Reflect.construct(target,args)`**

`Reflect`是一个静态类，不能实例化，也不能被继承，因此无法使用`new`操作符。但是`Reflect.construct`方法可以用来调用构造函数。

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

const p = Reflect.construct(Person, ["Bob", 18]);
console.log(p); // Person {name: '张三', age: 18}

//等价于
const p = new Person("Bob", 18);

```



- **`Reflect.get(target,name,receiver)`**

`Reflect.get`用于查找`target`对象的`name`属性，返回该属性的值。如果`name`属性不存在，则返回`undefined`。如果`target`的`name`属性部署了`getter`，那么`getter`的`this`是指向第三个参数`receiver`，若参数`receiver`省略，则`this`默认指向`target`。

```js
const studentA = {
  name: "Bob",
  age: 18,
  get info() {
    return `${this.name} is ${this.age}`;
  },
};

const studentB = {
  name: "Alice",
  age: 19,
};

console.log(Reflect.get(studentA, "info")); // Bob is 18

console.log(Reflect.get(studentA, "info", studentB)); // Alice is 19
```

- **`Reflect.set(target,name,value,receiver)`**

`Reflect.set`用于设置`target`对象的`name`属性等于`value`。如果`name`属性设置了`setter`，则`setter`的`this`绑定`receiver`。

```js
const studentA = {
  name: "Bob",
  set setSex(value) {
    this.sex = value;
  },
};

const studentB = {
  name: "Alice",
};

Reflect.set(studentA, "setSex", "male");
console.log(studentA.sex); // male
Reflect.set(studentA, "setSex", "female", studentB);
console.log(studentA.sex, studentB.sex); // male,female
```

- **`Reflect.defineProperty(target,name,desc)`**

`Reflect.defineProperty`方法基本等同于`Object.defineProperty`，返回一个布尔值。如果操作失败，会抛出一个错误。`Object.defineProperty`会逐渐被废弃。

另外`Reflect.defineProperty`的第一个参数必须是对象，否则会抛出错误。

```js
Reflect.defineProperty({}, "name", {
  value: "Bob", // 值
  writable: true, // 是否可写
  enumerable: true, // 是否可枚举
  configurable: true, // 是否可配置
});
```

- **`Reflect.deleteProperty(target,name)`**

`Reflect.deleteProperty`方法用于删除对象的属性，返回一个布尔值。如果删除成功，返回`true`；如果删除失败，返回`false`。

同理，若`Reflect.deleteProperty`的第一个参数不是对象，也会抛出错误。

- **`Reflect.has(target,name)`**

`Reflect.has`方法对应`name in target`的操作。如果`target`对象继承了`name`属性，返回`true`；否则返回`false`。相比`name in obj`写法，`Reflect.has`是函数的形式，且心智负担很小。

- **`Reflect.ownKeys(target)`**

`Reflect.ownKeys`方法用于返回对象的所有属性，包括不可枚举属性。它的返回值是一个数组，数组的成员是字符串，每个字符串对应一个属性名。

`Reflect.ownKeys`基本等同于`Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`，但它是一个静态方法，不需要实例化。

同理，若`Reflect.ownKeys`的第一个参数不是对象，也会抛出错误。

```js
Reflect.ownKeys({
  name: "Bob",
  age: 18,
  [Symbol("symbol")]: "symbol",
});

// ['name', 'age', Symbol(symbol)]
```

- **`Reflect.isExtensible(target)`**

`Reflect.isExtensible`方法对应`Object.isExtensible`方法，返回一个布尔值，表示当前对象是否可扩展。

同理，若`Reflect.isExtensible`的第一个参数不是对象，也会抛出错误。

在某些情况下，`Reflect.isExtensible(obj)`会返回`false`，如对象`obj`被`Object.preventExtensions(obj)`、`Object.seal(obj)`、`Object.freeze(obj)`等处理后，会返回`false`。另外，JS 某些内置对象也是不可扩展对象，如`Math`、`JSON`。

总结如下：

| 方法/状态                    | isExtensible | 能否添加属性 | 能否删除属性 | 能否修改值 |
| ---------------------------- | ------------ | ------------ | ------------ | ---------- |
| 默认对象                     | ✅ true       | ✅ 是         | ✅ 是         | ✅ 是       |
| `Object.preventExtensions()` | ❌ false      | ❌ 否         | ✅ 是         | ✅ 是       |
| `Object.seal()`              | ❌ false      | ❌ 否         | ❌ 否         | ✅ 是       |
| `Object.freeze()`            | ❌ false      | ❌ 否         | ❌ 否         | ❌ 否       |

- **`Reflect.preventExtensions(target)`**

`Reflect.preventExtensions(target)`对应`Object.preventExtension`方法，用于让一个对象变为不可扩展，返回一个布尔值，表示是否操作成功。

- **`Reflect.getOwnPropertyDescriptor(target,name)`**

`Reflect.getOwnPropertyDescriptor(target,name)`对应`Object.getOwnPropertyDescriptor`方法，用于获取对象的属性描述符，返回一个`PropertyDescriptor`对象。

```js
let p={}
Reflect.defineProperty(p,'name',{
    value:"Jinus",
    enumerable:false,
    writable:true,
    configurable:true,
})

console.log(Reflect.getOwnPropertyDescriptor(p,'name')) 
// {value:"Jinus",enumerable:false,writable:true,configurable:true,}

console.log(Reflect.getOwnPropertyDescriptor(p,'age')) 
// undefined  
```

- **`Reflect.getPrototypeOf(target)`**

`Reflect.getPrototypeOf`方法对应`Object.getPrototypeOf`，用于读取对象的`__proto__`属性，返回对象的原型。若参数`target`不是对象，`Reflect.getPrototypeOf`会报错，而`Object.getPrototypeOf`会将`target`转为对象，再获取该对象的`__prototype`。

- **`Reflect.setPrototypeOf(target,prototype)`**

`Reflect.setPrototypeOf`方法对应`Object.setPrototypeOf`，用于设置对象的原型`prototype`，返回一个布尔值，表示是否操作成功。

若参数`target`不是对象，`Reflect.setPrototypeOf`会报错，而`Object.setPrototypeOf`会返回`target`自身。特殊情况下，`target`为`null`或`undefined`，`Reflect.setPrototypeOf`会何`Object.setPrototypeOf`都会报错。
