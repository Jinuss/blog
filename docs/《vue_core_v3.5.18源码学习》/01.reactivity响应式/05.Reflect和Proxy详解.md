---
title: Reflect和Proxy详解
date: 2025-08-14 18:20:09
permalink: /pages/dee045/
categories:
  - 《vue_core_v3.5.18源码学习》
  - reactivity响应式
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

`Proxy`和 `Reflect`是都是在*ES6*中引入的新对象。它们也是vue3实现响应式的基础。这篇文章会深入理解分析这两个重要的角色。

## 正文

### `Proxy`

`Proxy`对象用于创建一个对象的代理，从而实现对目标对象的访问拦截和修改（如属性查找、赋值、枚举和函数调用）。

- 语法：`new Proxy(target, handler)`

`target`: 需要代理的目标对象（可以是任何类型，包括原生对象）

`handler`: 一个对象，其属性是当执行一个操作时定义代理的行为的函数。

#### `handler`实例方法

参照 MDN 文档，`handler`可以如下 13 种方法

- `handler.apply()`：用于拦截函数的调用

- `handler.construct()`：用于拦截构造函数`new`操作符的调用

- `handler.defineProperty()`：用于拦截对象`Object.defineProperty()`操作

- `handler.deleteProperty()`：用于拦截对对象属性的`delete`操作

- `handler.get()`：用于拦截对象属性的读取

- `handler.getOwnPropertyDescriptor()`：用于拦截`Object.getOwnPropertyDescriptor()`操作

- `handler.getPrototypeOf()`：是一个代理方法，当读取代理对象的原型时，该方法就会被调用

- `handler.has()`：拦截`in`操作符

- `handler.isExtensible()`：拦截`Object.isExtensible()`操作

- `handler.ownKeys()`：拦截`Reflect.ownKeys()`，返回一个数组;还可拦截`Object.getOwnPropertyNames()`和`Object.getOwnPropertySymbols()`,`Object.keys()`等

- `handler.preventExtensions()`：拦截`Object.preventExtensions()`

- `handler.set()`: 拦截`set`操作

- `handler.setPrototypeOf()`：拦截`Object.setPrototypeOf()`


### `Reflect`

`Reflect`对象是*ES6*为了操作对象而提供的新API，它提供了拦截 JavaScript 操作对象的方法。这些方法与`Proxy`的`handler`方法相对应。

#### `Reflect`静态方法

`Reflect`对象一共有13个静态方法，大部分与`Object`对象的同名方法的作用相同，并且与`Proxy`对象的方法相对应。

- `Reflect.apply(target,thisArg,args)`：
- `Reflect.construct(target,args)`

- **`Reflect.get(target,name,receiver)`**

`Reflect.get`用于查找`target`对象的`name`属性，返回该属性的值。如果`name`属性不存在，则返回`undefined`。如果`target`的`name`属性部署了`getter`，那么`getter`的`this`是指向第三个参数`receiver`，若参数`receiver`省略，则`this`默认指向`target`。

```js
const studentA = {
  name: 'Bob',
  age: 18,
  get info() {
    return `${this.name} is ${this.age}`
  }
}

const studentB = {
  name: 'Alice',
  age: 19
}

console.log(Reflect.get(studentA, 'info')) // Bob is 18

console.log(Reflect.get(studentA, 'info',studentB)) // Alice is 19

```

- **`Reflect.set(target,name,value,receiver)`**

`Reflect.set`用于设置`target`对象的`name`属性等于`value`。如果`name`属性设置了`setter`，则`setter`的`this`绑定`receiver`。

```js
const studentA = {
  name: 'Bob',
  set setSex(value) {
    this.sex = value
  }
}

const studentB = {
  name: 'Alice',
}

Reflect.set(studentA, 'setSex', 'male')
console.log(studentA.sex) // male
Reflect.set(studentA, 'setSex', 'female',studentB)
console.log(studentA.sex, studentB.sex) // male,female
```

- `Reflect.defineProperty(target,name,desc)`：
- `Reflect.deleteProperty(target,name)`：
- `Reflect.has(target,name)`
- `Reflect.ownKeys(target)`
- `Reflect.isExtensible(target)`：
- `Reflect.preventExtensions(target)`：
- `Reflect.getOwnPropertyDescriptor(target,name)`：
- `Reflect.getPrototypeOf(target)`：
- `Reflect.setPrototypeOf(target,prototype)`：