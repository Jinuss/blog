---
title: reactive响应式对象依赖的收集与触发监听
date: 2025-08-22 16:02:45
permalink: /pages/444443/
categories:
  - 《vue_core_v3.5.18源码学习》
  - reactivity响应式
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

在`BaseReactiveHandler`类的`get`方法中，有如下代码块`if (!isReadonly2){track(target, "get", key);}`，这表示通过`reactive`、`shallowReactive`创建的响应式对象，非只读的，当读取代理对象`proxyTarget`的某个属性`key`时，都会被该`get`方法拦截，即调用`track()`方法建立依赖。

而当对代理对象`proxyTarget`进行赋值或更新某个属性的值时，会被`set`方法拦截，即调用`trigger()`方法触发依赖（而删除会被`deleteProperty`拦截）。

因此对于`reactive`响应式对象的响应式处理，和`track`与`trigger`方法密不可分。

本文主要介绍`track`与`trigger`是如何进行依赖的收集与触发的全流程。

## 源码分析

在vue3中，维护了一个全局的`targetMap` `WeakMap`实例对象，用于存储响应式对象与依赖的映射关系。

```js
const targetMap = new WeakMap();
```

### `track`方法

`track`方法收集依赖就是往变量`targetMap`中添加相关元素，存储响应式对象与依赖的映射关系。

`track`的源码实现如下：

```js
function track(target, type, key) {
    if (shouldTrack && activeSub) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, depsMap = new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, dep = new Dep());
            dep.map = depsMap;
            dep.key = key;
        }
        dep.track();
    }
}
```

这里暂且不论`shouldTrack`和`activeSub`，假定满足`track`的条件。首先从`targetMap`中读取`depsMap`，若`depsMap`中不存在，则创建一个新的`Map`的实例，并将其赋值给`depsMap`，并且存储到`targetMap`中。然后从`depsMap`中获取`key`对应的依赖关系`dep`，同理，若`dep`不存在，则创建一个新的`Dep`实例，并将其赋值给`dep`，并且存储到`depsMap`中，然后将`dep`的`map`和`key`分别绑定`depsMap`、`key`。最后调用`dep.track()`方法。

`dep.track()`执行后，会将当前的`activeSub`添加到`dep`的`subs`数组中？。

### `trigger`方法

`track`方法的源码实现如下：

```js
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        globalVersion++;
        return;
    }
    const run = (dep) => {
        if (dep) {
            dep.trigger();
        }
    };
    startBatch();
    if (type === "clear") {
        depsMap.forEach(run);
    } else {
        const targetIsArray = isArray(target);
        const isArrayIndex = targetIsArray && isIntegerKey(key);
        if (targetIsArray && key === "length") {
            const newLength = Number(newValue);
            depsMap.forEach((dep, key2) => {
                if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
                    run(dep);
                }
            });
        } else {
            if (key !== void 0 || depsMap.has(void 0)) {
                run(depsMap.get(key));
            }
            if (isArrayIndex) {
                run(depsMap.get(ARRAY_ITERATE_KEY));
            }
            switch (type) {
                case "add":
                    if (!targetIsArray) {
                        run(depsMap.get(ITERATE_KEY));
                        if (isMap(target)) {
                            run(depsMap.get(MAP_KEY_ITERATE_KEY));
                        }
                    } else if (isArrayIndex) {
                        run(depsMap.get("length"));
                    }
                    break;
                case "delete":
                    if (!targetIsArray) {
                        run(depsMap.get(ITERATE_KEY));
                        if (isMap(target)) {
                            run(depsMap.get(MAP_KEY_ITERATE_KEY));
                        }
                    }
                    break;
                case "set":
                    if (isMap(target)) {
                        run(depsMap.get(ITERATE_KEY));
                    }
                    break;
            }
        }
    }
    endBatch();
}
```