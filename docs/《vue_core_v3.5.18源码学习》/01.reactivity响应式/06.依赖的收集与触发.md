---
title: 依赖的收集与触发
date: 2025-08-20 15:16:21
permalink: /pages/8f91f7/
categories:
  - 5.18源码学习》
  - reactivity响应式
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

本文主要讲述vue3中的`Dep`，`Dep`的全称为`Dependency`，即依赖的意思。在vue3中，`Dep`的主要作用是收集依赖和触发依赖。具体参考`packages\reactivity\src\dep.ts`

## 源码分析

在解析`Dep`之前，先回顾下`ref`响应的实现，伪代码如下：

```js
class RefImpl{
    constructor(value){
        this._value = value;
        this.dep= new Dep();
    }
    get value(){
        this.dep.track();
        return this._value;
    }
    set value(){
        if (hasChanged(newValue, oldValue)) {
        {
          this.dep.trigger();
        }
      }
    }
}
```

当`ref`对象的`value`属性被访问时，会触发`get`方法，在`get`方法中会调用`dep.track`方法，将当前的`ref`对象添加到`dep`的依赖列表中；当`ref`对象的`value`属性被赋值时，会触发`set`方法，若新值与旧值不同，则会调用`dep.trigger`方法，触发`dep`的依赖列表中的所有依赖；若新值与旧值相同，则不会触发依赖。

所以`Dep`与响应式是密切相关的。

### `Dep`类

`Dep`类的源码实现如下：

```js
let globalVersion = 0;

let activeSub;

let shouldTrack = true;

class Dep {
    constructor(computed) {
        this.computed = computed;
        this.version = 0;
        this.activeLink = undefined;
        this.subs = undefined;
        this.subsHead = undefined;
        this.map = undefined;
        this.key = undefined;
        this.sc = 0;
        this["__v_skip"] = true;
    }

    track() {
        if (!activeSub || !shouldTrack || activeSub === this.computed) {
            return;
        }
        let link = this.activeLink;
        if (link === void 0 || link.sub !== activeSub) {
            link = this.activeLink = new Link(activeSub, this);
            if (!activeSub.deps) {
                activeSub.deps = activeSub.depsTail = link;
            } else {
                link.prevDep = activeSub.depsTail;
                activeSub.depsTail.nextDep = link;
                activeSub.depsTail = link;
            }
            addSub(link)
        } else if (link.version === -1) {
            link.version = this.version;
            if (link.nextDep) {
                const next = link.nextDep;
                next.prevDep = link.prevDep;
                if (link.prevDep) {
                    link.prevDep.nextDep = next;
                }
                link.prevDep = activeSub.depsTail;
                link.nextDep = void 0;
                activeSub.depsTail.nextDep = link;
                activeSub.depsTail = link;
                if (activeSub.deps === link) {
                    activeSub.deps = next;
                }
            }
        }
        return link;
    }
    trigger(debugInfo) {
        this.version++;
        globalVersion++;
        this.notify(debugInfo);
    }
    notify(debugInfo) {
        startBatch();
        try {
            for (let link = this.subs; link; link = link.prevSub) {
                if (link.sub.notify()) {
                    link.sub.dep.notify();
                }
            }
        } finally {
            endBatch();
        }
    }
}
```

### 辅助类或方法

#### `Link`类

`Link`类用于建立响应式依赖(**`Dep`**)与副作用订阅者(**`Subscriber`**)之间的双向关联，主要解决动态依赖追踪和高效清理问题。


`Link`类的源码实现如下：

```js
class Link{
    constructor(sub,dep){
        this.sub = sub; // 订阅者
        this.dep = dep; // 依赖集合
        this.version = dep.version; //版本标记
        this.nextDep = undefined; // 下一个依赖
        this.prevDep = undefined; // 上一个依赖
        this.nextSub = undefined; // 下一个订阅者
        this.prevSub = undefined; // 上一个订阅者
        this.prevActiveLink = undefined; // 上一个活动链接
    }
}
```
- **核心逻辑**：
  1. 副作用函数执行前：所有旧链接的`version`设置为`-1`
  2. 访问依赖时，同步更新`version`的值为`Dep`的`version`
  3. 副作用执行完成后，清理`version`仍为`-1`的链接；因为`-1`表示该依赖在本次副作用函数执行中未被引用。

#### `addSub`

```js
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
```

#### `startBatch`、`endBatch`和`batch`


```js
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
```