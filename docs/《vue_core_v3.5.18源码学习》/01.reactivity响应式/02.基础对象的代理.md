---
title: 基础对象的代理
date: 2025-08-13 18:13:14
permalink: /pages/08c83c/
categories:
  - 《vue_core_v3.5.18源码学习》
  - reactivity响应式
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概览

基础对象的代理指的是对基础对象进行代理，使基础对象的属性可以被响应式地访问和修改。该实现具体参见
`packages\reactivity\src\baseHandlers.ts`

本文主要介绍如下四类基础对象的代理方法：
- `mutableHandlers`：可读写代理
- `readonlyHandlers`：只读代理
- `shallowReactiveHandlers`：浅响应式代理
- `shallowReadonlyHandlers`：浅只读代理

## 源码分析

实际上上述四类代理方法只是实例化了两个类`MutableReactiveHandler`和`ReadonlyReactiveHandler`

```js
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
```
而`MutableReactiveHandler`和`ReadonlyReactiveHandler`都是继承于`BaseReactiveHandler`类的，`BaseReactiveHandler`类的主要功能是定义基础的代理方法，而`MutableReactiveHandler`和`ReadonlyReactiveHandler`类则是在基础的代理方法上进行了扩展，添加了可读写和只读的功能。

### `BaseReactiveHandler`类

`BaseReactiveHandler`类的实现如下：

```js

function hasOwnProperty(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  // 依赖收集
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}

class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the reciever is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, isRef(target) ? target : receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
```

`BaseReactiveHandler`类只是定义了`get()`方法，当读取代理对象时，会触发`get()`方法进行拦截，在非只读的情况下，会调用`track`方法进行依赖收集。如下是`BaseReactiveHandler`类的实现过程分析：
 1. 类的构造器接收两个参数:`_isReadonly` 和 `_isShallow`，分别表示是否只读和是否是浅层响应式.
 2. `get()`方法接收三个参数:`target`目标对象、`key`属性名、`receiver`代理对象。当`get()`方法被触发时，若`key`是`__v_isReactive`、`__v_isShallow`或者`__v_raw`，则根据实例的`_isReadonly`或者`_isShallow`返回对应的布尔值.
 3. 若`key`是`__v_raw`，则根据`_isReadonly`和`_isShallow`确定代理对象的缓存（即调用`createReactiveObject`中的`proxyMap`缓存变量），然后比较`receiver`是否是缓存中的代理对象，如果是，则返回目标对象`target`；若不是，则判断`target`和`receiver`的原型是否相等，若相等，则返回目标对象`target`.如果二者皆不相等，则什么也不返回.
 4. 若`key`不是上述属性，则判断`target`是否是数组。如果是可写的，且`target`是数组，`key`又是数组的属性，那么就返回数组的方法。若`key`是`hasOwnProperty`，则返回自定义的`hasOwnProperty`方法，该方法的实现如上，该方法的作用是判断`target`是否有`key`属性，并且调用`track`进行依赖收集.
 5. 调用`Reflect.get(target, key, receiver)`方法获取`target`上`key`的值`res`.
 6. 判断`key`是不是内置的`Symbol`属性或一些普通属性`__proto__,__v_isRef,__isVue`,若是，则直接返回`res`，避免对这些属性进行依赖收集.
 7. 判断是否只读，若不是只读，则调用`track`进行依赖收集.
 8. 判断是否是浅层响应式，若是，则直接返回`res`，避免对`res`进行递归代理.
 9. 判断`res`是否是`Ref`对象，若是，则继续判断，若`target`是数组且`key`是整数索引，则返回`res`;否则返回`res.value`.
 10. 若`res`是对象，则判断是否只读，若不是只读，则递归调用`reactive`进行代理，否则递归调用`readonly`进行代理.
 11. 最后返回`res`.

### `MutableReactiveHandler`类

`MutableReactiveHandler`的实现如下：

```js
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
```

`MutableReactiveHandler`类继承于`BaseReactiveHandler`类，在其内部定义了`set`、`deleteProperty`、`has`、`ownKeys`方法四个方法。在它的构造函数中，接受一个参数`isShallow2`表示是否是浅层响应，默认为`false`，然后调用`super`，响应式对象肯定不是只读的，所以`super`第一个参数是`false`。如下分析`MutableReactiveHandler`的四个方法。

#### `set`

当`target`目标对象上的值发生改变，或者说是对`target`进行写操作时，会调用`set`方法。

`set`方法接收四个参数：`target`目标对象、`key`属性名、`value`属性值、`receiver`代理对象。
1. 首先获取`target`的旧值`oldValue`,判断是否是浅层代理，若不是，则继续判断新值，若新值是深层响应式，则分别调用`toRaw`获取新值和旧值的原始值；然后判断，若`target`是对象，且旧值是`Ref`对象而新值不是`Ref`对象，若旧值是只读的，则返回`false`;否则将旧值的`value`属性赋值为新值,返回`true`.
2. 若`target`不是数组，且`key`是整数索引且`key`的长度小于`target`数组的长度，则说明是在更新`target[key]`的值；若`target`不是数组，则调用自定义方法`hasOwn`（实际就是`Object.prototype.hasOwnProperty`）判断`target`是否有`key`属性.
`hadKey`用于表示是更新还是新增操作，`true`则更新/`false`则新增.
3. 调用`Reflect.set`设置`target`的`key`为`value`,返回结果保存至变量`result`。
4. 判断`target`和`receiver`的原始对象是否相等，只有相等才触发副作用。这个检查是为了避免在原型链上的属性设置时错误地触发副作用。然后判断`hadKey`，若`hadKey`为`true`，则说明是更新操作，会先调用`hasChanged`判断新旧值是否相等，若不等，则调用`trigger`触发更新副作用；若`hadKey`为`false`，则说明是新增操作，调用`trigger`触发新增副作用.
5. 最后返回`result`

#### `deleteProperty`

`deleteProperty`方法在删除`target`上的某属性时会被触发。

`deleteProperty`方法接收两个参数：`target`目标对象、`key`属性名。
1. 调用`hasOwn`判断`target`是否有`key`属性，判断结果记为`hadKey`，获取旧值`oldValue`。
2. 调用`Reflect.deleteProperty`删除`target`的`key`属性，返回结果保存至变量`result`。
3. 判断`result`与`hadKey`都为`true`，则调用`trigger`触发删除副作用。
4. 最后返回`result`

#### `has`

`has`方法会拦截`in`操作符。如下是它的处理流程：
1. 调用`Reflect.has`判断`target`是否有`key`属性，记为`result`
2. 判断`key`是否是`Symbol`类型或者`key`是否是内置的`Symbol`，若不是，则调用`track`进行依赖收集.
3. 最后返回属性检测的结果`result`

#### `ownKeys`

`ownKeys`方法会拦截`Object.keys`、`Object.getOwnPropertyNames`、`Object.getOwnPropertySymbols`、`for...in`循环。如下是它的处理流程：
1. 调用`track`进行依赖收集。若`target`是数组，则跟踪`length`属性的变化；若`target`不是数组，则跟踪`Symbol(iterator)`。这样当对对象的属性添加、删除或数组长度变化时，就会触发相关的副作用函数。
2. 最后返回目标对象的所有自有属性键

### `ReadonlyReactiveHandler`类

`ReadonlyReactiveHandler`类就更简单了，因为通过该类实例化的处理器方法都是针对只读对象的，所以它的`set`、`deleteProperty`方法都直接返回`true`，并在`warn`中提示目标对象是只读的。

`ReadonlyReactiveHandler`的实现如下：

```js
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
}
```