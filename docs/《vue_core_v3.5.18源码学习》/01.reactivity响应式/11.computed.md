---
title: computed
date: 2025-08-26 17:36:05
permalink: /pages/fb7d8d/
categories:
  - 《vue_core_v3.5.18源码学习》
  - reactivity响应式
tags:
  - 
author: 
  name: 东流
  link: https://github.com/Jinuss
---

## 概述

vue3中，`computed`函数用于表示计算属性，有惰性求值、响应式追踪依赖的特点。本文将介绍`computed`的实现原理以及其机制细节。

## 源码解析

`computed`计算属性和`computed`方法、`ComputedRefImpl`类以及`refreshComputed`方法有关。

### `computed`方法

`computed`暴露给外部的就是`computed`方法，其源码实现如下：

```js
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (shared.isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
```

`computed`方法实现比较简单，需要关注参数`getterOrOptions`和`isSSR`，`isSSR`默认为`false`，它在服务端渲染会传值为`true`。`debugOptions`用以在开发环境调试。

`computed`会先判断`getterOrOptions`是否是函数，若是函数，则将其赋值给`getter`；当然`getterOptions`也可以是一个包含`get`和`set`方法的对象。`computed`方法返回的是`ComputedRefImpl`实例，一般我们读取计算属性的值也是读取它的返回值的`.value`。


### `ComputedRefImpl`类

`ComputedRefImpl`用于构造一个计算属性。

`ComputedRefImpl`的源码实现如下：
```js
class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
        this.fn = getter; //计算函数
        this.setter = setter; // 设置函数（可选）
        this["_value"] = undefined; // 缓存的结果，计算属性的值
        this.dep = new Dep(this); // 依赖收集器（收集依赖此计算属性的副作用effect）
        this["__v_isRef"] = true; // 表示为ref类型
        this["__v_isReadonly"] = undefined; // 只读标记
        this.deps = undefined; //当前计算属性依赖的响应式集合对象链表头
        this.depsTail = undefined; //链表尾
        this.flags = 16; //状态标记
        this.globalVersion = globalVersion - 1;// 全局版本号，用于脏检查
        this.isSSR = undefined; //服务端渲染标记
        this.next = undefined; //用于在effect链表中指向下一个节点
        this.effect = this; // 指向自身
        this["__V_isReadonly"] = !setter; //若无setter，则表示计算属性是只读的
        this.isSSR = isSSR;//ssr标记赋值
    }
    notify() {
        this.flags |= 16;
        if (!(this.flags & 8) && activeSub !== this) {
            batch(this, true);
            return true;
        }
    }
    get value() {
        const link = this.dep.track()
        refreshComputed(this);
        if (link) {
            link.version = this.dep.version;
        }
        return this._value;
    }
    set value(newValue) {
        if (this.setter) {
            this.setter(newValue)
        } else {
            warn("Write operation failed: computed value is readonly");
        }
    }
}
```

```js
function refreshComputed(computed) {
    if (computed.flags & 4 && !(computed.flags & 16)) {
        return;
    }
    computed.flags & =-17;
    if (computed.globalVersion === globalVersion) {
        return;
    }
    computed.globalVersion = globalVersion;
    if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {
        return;
    }
    computed.flags |= 2;
    const dep = computed.dep;
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed;
    shouldTrack = true;
    try {
        prepareDeps(computed);
        const value = computed.fn(computed._value);
        if (dep.version === 0 || hasChanged(value, computed._value)) {
            computed.flags |= 128;
            computed._value = value;
            dep.version++;
        }
    } catch (err) {
        dep.version++;
        throw err;
    } finally {
        activeSub = prevSub;
        shouldTrack = prevShouldTrack;
        cleanupDep(computed);
        computed.flags &= -3;
    }
}
```